## 定義函式Function(三)
### 提前退出

正常情況是必須達到函示的末尾，但是如果編寫包含許多語法的函式通常會在意識到沒有更多計算要做時因此需要提前退出該函式

```rust
fn f(x: i32) -> i32 {
    if x <= 0 {
        return 0;
    }

    return x * 5;
}

println!("{} {}", f(10), f(0))

輸出
50 0
```

### 返回多個值

如果要從函式返回多個值，可以使用元組型別

```rust
fn f(x: i32) -> (i32, i32) {
    return (x * 5, 10);
}

println!("{:?}", f(10))

輸出
(50, 10)
```

或是也可以用返回結構，元組結構，數組或是向量來返回多個

### 更改調用者的變數

假設有個包含數字的數組，要更改其中的數字

```rust
fn f(mut a: [i32; 5]) {
    for i in 0..5 {
        if a[i] > 0 {
            a[i] *= 2;
        }
    }
}

let mut arr = [5, -1, 2, -2, 8];
f(arr);
println!("{:?}", arr);

輸出
[5, -1, 2, -2, 8]
```

可以看到並沒有改變數組，並且在編譯時出現警告variable does not need to be mutable

告訴我們mut聲明arr之後卻沒有改變可以移除

比較麻煩的作法，可以透過回傳值回傳一個新的數組，缺點就是數組會複製兩次

```rust
fn f(mut a: [i32; 5]) -> [i32; 5] {
    for i in 0..5 {
        if a[i] > 0 {
            a[i] *= 2;
        }
    }

    return a;
}

let mut arr = [5, -1, 2, -2, 8];
arr = f(arr);
println!("{:?}", arr);

輸出
[10, -1, 4, -2, 16]
```

可以透過引用傳遞參數的方式來改變數組

```rust
fn f(a: &mut [i32; 5]) {
    for i in 0..5 {
        if (*a)[i] > 0 {
            (*a)[i] *= 2;
        }
    }
}

let mut arr = [5, -1, 2, -2, 8];
f(&mut arr);
println!("{:?}", arr);

輸出
[10, -1, 4, -2, 16]
```

透過&符號來表示物件記憶體位址，而使用*符號表示記憶體位址的物件

通過型別宣告&mut [i32; 5]指定它是物件的地址(可以稱為指針Pointer或是引用reference)

這邊的使用跟C++使用很像，區別是Rust還允許顯式的取消引用可以省略*符號

這個函式等同於上面

```rust
fn f(a: &mut [i32; 5]) {
    for i in 0..5 {
        if a[i] > 0 { // 省略了*
            a[i] *= 2; // 省略了*
        }
    }
}

let mut arr = [5, -1, 2, -2, 8];
f(&mut arr);
println!("{:?}", arr);

輸出
[10, -1, 4, -2, 16]
```