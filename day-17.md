## 定義函式Function(二)

### 函式傳遞參數

每次調用函式時都打印相同的hello word的函式不是很有用處

這時候可以傳遞參數給函式會顯得更有意義

```rust
fn hello_word(name: String) {
    println!("{} hello", name)
}

hello_word(String::from("Mike"));

輸出
Mike hello
```

函式參數的定義與變數定義非常相似

因此可以將面的函式解釋為

```rust
{
    let name: String = String::from("Mike");
    println!("{} hello", name)
}
```

變數的定義與函式參數的定義主要的差別在於函式定義需要明確的指定類型

變數的定義可以依賴類型推斷

編譯器會使用類型推斷來檢查參數值是否合法

```rust
fn f(c: i16) {}

f(5.); // 非法因為是浮點數
f(5u16); // 非法因為是u16型別
f(5i16); // 合法
f(5); // 合法因為傳遞是無約束得整數類型參數會變函式限制為i16類型
```

### 函式按"值"傳遞參數

參數不僅僅是傳遞物件的新名稱是傳遞物件的副本，此副本在調用函式時創建並在函式結束且控制返回到調用者時銷毀它

例如下面

```rust
fn test(mut f: f64) {
    f *= 10.;
    println!("{}", f)
}

let f = 5.;
test(f);
println!("{}", f);

輸出
50
5
```

在一開始就宣告的f變數在傳遞給test函式的，並在函式中保留使用f變數並更改變數得值並打印，函式結束反給調用者，然侯在印出f變數，這個變數與調用時一樣

實際上傳遞給函式的不是這個變數而是變數的"值"並在函式結尾時銷毀

### 函式返回值

函式除了能接收參數之外還可以計算結果並返回給調用者

```rust
fn test(f: f64) -> f64 {
    return f * 10.;
}

println!("{}", test(5.));
```

返回值需要再函式簽名之後用"→"並指定型別